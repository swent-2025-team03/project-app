rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    function isSignedIn() { return request.auth != null; }

		function hasRole(role) {
      return request.auth != null
          && exists(/databases/$(database)/documents/users/$(request.auth.uid))
          && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == role;
    }

    // ---- Users ----
    match /users/{userID} {
      // Read own document OR another user's doc if an active connection exists (A__B or B__A)
      allow get: if isSignedIn() && (
        request.auth.uid == userID ||
        (
          exists(/databases/$(database)/documents/connections/$(request.auth.uid + "__" + userID)) &&
          get(/databases/$(database)/documents/connections/$(request.auth.uid + "__" + userID)).data.active == true
        ) ||
        (
          exists(/databases/$(database)/documents/connections/$(userID + "__" + request.auth.uid)) &&
          get(/databases/$(database)/documents/connections/$(userID + "__" + request.auth.uid)).data.active == true
        )
      );

      // Disallow listing to prevent user enumeration
      allow list: if false;

      // Create and delete only own document
      allow create, delete: if isSignedIn() && request.auth.uid == userID;

      // Prevent privilege escalation (cannot change 'role' or 'uid')
      allow update: if isSignedIn() &&
        request.auth.uid == userID &&
        !(request.resource.data.diff(resource.data).changedKeys().hasAny(['role','uid']));
    }

    // ---- Connect codes ----
    match /connect_codes/{code} {
      allow create: if hasRole("Vet");
	  	allow update: if hasRole("Farmer");
	  	allow read: if request.auth != null;
    }

    // ---- Connections ----
    match /connections/{id} {
      // Read allowed only for the two connected parties
      allow get: if isSignedIn() &&
        request.auth.uid in [resource.data.farmerId, resource.data.vetId];

      // Disallow listing of all connections
      allow list: if false;

      // Create or update allowed only for the two parties, on a valid ID and schema
      allow create, update: if isSignedIn() &&
        // Author must be one of the two parties
        request.auth.uid in [request.resource.data.farmerId, request.resource.data.vetId] &&
        // Document ID must be min(a,b) + "__" + max(a,b)
        id == (
          request.resource.data.farmerId < request.resource.data.vetId
            ? request.resource.data.farmerId + "__" + request.resource.data.vetId
            : request.resource.data.vetId + "__" + request.resource.data.farmerId
        ) &&
        // Type checks
        request.resource.data.farmerId is string &&
        request.resource.data.vetId    is string &&
        request.resource.data.active   is bool &&
        // Optional createdAt field must be a timestamp if present
        (!('createdAt' in request.resource.data) || request.resource.data.createdAt is timestamp) &&
        // For updates: farmerId and vetId cannot be changed
        (request.method == 'create' ||
         !(request.resource.data.diff(resource.data).changedKeys().hasAny(['farmerId','vetId'])));
    }

    // ---- Reports ----
    match /reports/{reportID} {
      // Read and delete allowed only for the vet or the farmer
      allow read, delete: if isSignedIn() &&
        (request.auth.uid == resource.data.farmerId ||
         request.auth.uid == resource.data.vetId);

      // Updates allowed for both, but they cannot change vetId/farmerId
      allow update: if isSignedIn() &&
        (request.auth.uid == resource.data.farmerId ||
         request.auth.uid == resource.data.vetId) &&
        !(request.resource.data.diff(resource.data).changedKeys().hasAny(['vetId','farmerId']));

      // Only the farmer can create a new report
      allow create: if isSignedIn() &&
        request.auth.uid == request.resource.data.farmerId;
    }
  }
}
